{
  "React Component with TypeScript": {
    "prefix": "rfc",
    "body": [
      "import { FC } from 'react';",
      "",
      "interface ${1:ComponentName}Props {",
      "  $2",
      "}",
      "",
      "export const ${1:ComponentName}: FC<${1:ComponentName}Props> = ({ $3 }) => {",
      "  return (",
      "    <div>",
      "      $4",
      "    </div>",
      "  );",
      "};",
      ""
    ],
    "description": "React functional component with TypeScript"
  },
  "Express API Route": {
    "prefix": "apiRoute",
    "body": [
      "app.${1:get}('${2:/api/endpoint}', async (req, res) => {",
      "  try {",
      "    const { $3 } = req.${4:params};",
      "    ",
      "    // TODO: Implement logic",
      "    $5",
      "    ",
      "    res.json({ success: true, data: $6 });",
      "  } catch (error) {",
      "    console.error('Error in ${2:/api/endpoint}:', error);",
      "    res.status(500).json({ error: 'Internal server error' });",
      "  }",
      "});",
      ""
    ],
    "description": "Express API route with error handling"
  },
  "Drizzle Query": {
    "prefix": "drizzleQuery",
    "body": [
      "const ${1:result} = await db",
      "  .select()",
      "  .from(${2:tableName})",
      "  .where(eq(${2:tableName}.${3:column}, ${4:value}));",
      ""
    ],
    "description": "Drizzle ORM select query"
  },
  "Drizzle Insert": {
    "prefix": "drizzleInsert",
    "body": [
      "const [${1:result}] = await db",
      "  .insert(${2:tableName})",
      "  .values({",
      "    ${3:column}: ${4:value},",
      "  })",
      "  .returning();",
      ""
    ],
    "description": "Drizzle ORM insert with returning"
  },
  "Drizzle Update": {
    "prefix": "drizzleUpdate",
    "body": [
      "const [${1:result}] = await db",
      "  .update(${2:tableName})",
      "  .set({",
      "    ${3:column}: ${4:value},",
      "  })",
      "  .where(eq(${2:tableName}.${5:id}, ${6:value}))",
      "  .returning();",
      ""
    ],
    "description": "Drizzle ORM update with returning"
  },
  "React Query Hook": {
    "prefix": "useQuery",
    "body": [
      "const { data: ${1:dataName}, isLoading, error } = useQuery({",
      "  queryKey: ['${2:queryKey}', ${3:params}],",
      "  queryFn: async () => {",
      "    const response = await fetch('${4:/api/endpoint}');",
      "    if (!response.ok) throw new Error('Failed to fetch');",
      "    return response.json();",
      "  },",
      "});",
      ""
    ],
    "description": "React Query useQuery hook"
  },
  "React Mutation Hook": {
    "prefix": "useMutation",
    "body": [
      "const ${1:mutation} = useMutation({",
      "  mutationFn: async (${2:data}: ${3:DataType}) => {",
      "    const response = await fetch('${4:/api/endpoint}', {",
      "      method: '${5:POST}',",
      "      headers: { 'Content-Type': 'application/json' },",
      "      body: JSON.stringify(${2:data}),",
      "    });",
      "    if (!response.ok) throw new Error('Request failed');",
      "    return response.json();",
      "  },",
      "  onSuccess: () => {",
      "    // Invalidate and refetch",
      "    queryClient.invalidateQueries({ queryKey: ['${6:queryKey}'] });",
      "  },",
      "});",
      ""
    ],
    "description": "React Query useMutation hook"
  },
  "shadcn Form": {
    "prefix": "shadcnForm",
    "body": [
      "const form = useForm<z.infer<typeof ${1:formSchema}>>({",
      "  resolver: zodResolver(${1:formSchema}),",
      "  defaultValues: {",
      "    ${2:fieldName}: '',",
      "  },",
      "});",
      "",
      "const onSubmit = async (values: z.infer<typeof ${1:formSchema}>) => {",
      "  try {",
      "    $3",
      "  } catch (error) {",
      "    console.error('Form submission error:', error);",
      "  }",
      "};",
      ""
    ],
    "description": "shadcn/ui form setup with react-hook-form"
  },
  "Zod Schema": {
    "prefix": "zodSchema",
    "body": [
      "const ${1:schemaName} = z.object({",
      "  ${2:fieldName}: z.string().min(1, '${3:Field is required}'),",
      "  $4",
      "});",
      "",
      "type ${5:TypeName} = z.infer<typeof ${1:schemaName}>;",
      ""
    ],
    "description": "Zod validation schema"
  },
  "Try-Catch Block": {
    "prefix": "tryc",
    "body": [
      "try {",
      "  $1",
      "} catch (error) {",
      "  console.error('${2:Error message}:', error);",
      "  $3",
      "}",
      ""
    ],
    "description": "Try-catch error handling"
  },
  "Console Log": {
    "prefix": "clg",
    "body": ["console.log('${1:label}:', ${2:variable});", ""],
    "description": "Console log with label"
  },
  "Customer Isolation Query": {
    "prefix": "customerQuery",
    "body": [
      "const ${1:result} = await db",
      "  .select()",
      "  .from(${2:tableName})",
      "  .where(",
      "    and(",
      "      eq(${2:tableName}.customerId, customerId),",
      "      eq(${2:tableName}.${3:column}, ${4:value})",
      "    )",
      "  );",
      ""
    ],
    "description": "Drizzle query with customer isolation"
  },
  "AI Function Call": {
    "prefix": "aiFunction",
    "body": [
      "const completion = await openai.chat.completions.create({",
      "  model: '${1:gpt-4o}',",
      "  messages: [",
      "    { role: 'system', content: '${2:System prompt}' },",
      "    { role: 'user', content: ${3:userMessage} }",
      "  ],",
      "  functions: [${4:functionDefinitions}],",
      "  function_call: 'auto',",
      "});",
      "",
      "const functionCall = completion.choices[0].message.function_call;",
      ""
    ],
    "description": "OpenAI function calling pattern"
  },
  "Authenticated Route": {
    "prefix": "authRoute",
    "body": [
      "app.${1:get}('${2:/api/endpoint}', async (req, res) => {",
      "  if (!req.session?.userId) {",
      "    return res.status(401).json({ error: 'Not authenticated' });",
      "  }",
      "  ",
      "  try {",
      "    const customerId = req.session.customerId;",
      "    ",
      "    $3",
      "    ",
      "    res.json({ success: true, data: $4 });",
      "  } catch (error) {",
      "    console.error('Error in ${2:/api/endpoint}:', error);",
      "    res.status(500).json({ error: 'Internal server error' });",
      "  }",
      "});",
      ""
    ],
    "description": "Express route with authentication check"
  },
  "Tailwind Card Component": {
    "prefix": "twcard",
    "body": [
      "<div className=\"rounded-lg border bg-card text-card-foreground shadow-sm\">",
      "  <div className=\"flex flex-col space-y-1.5 p-6\">",
      "    <h3 className=\"text-2xl font-semibold leading-none tracking-tight\">",
      "      ${1:Card Title}",
      "    </h3>",
      "    <p className=\"text-sm text-muted-foreground\">",
      "      ${2:Card description}",
      "    </p>",
      "  </div>",
      "  <div className=\"p-6 pt-0\">",
      "    ${3:Card content}",
      "  </div>",
      "</div>",
      ""
    ],
    "description": "Tailwind CSS card component"
  },
  "Tailwind Button": {
    "prefix": "twbtn",
    "body": [
      "<button className=\"inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2\">",
      "  ${1:Button Text}",
      "</button>",
      ""
    ],
    "description": "Tailwind CSS button"
  },
  "Tailwind Container": {
    "prefix": "twcontainer",
    "body": [
      "<div className=\"container mx-auto px-4 ${1:py-8}\">",
      "  ${2:Content}",
      "</div>",
      ""
    ],
    "description": "Tailwind container with padding"
  },
  "Tailwind Flex Center": {
    "prefix": "twflex",
    "body": [
      "<div className=\"flex items-center justify-center ${1:gap-4}\">",
      "  ${2:Content}",
      "</div>",
      ""
    ],
    "description": "Tailwind flex container centered"
  },
  "Tailwind Grid": {
    "prefix": "twgrid",
    "body": [
      "<div className=\"grid grid-cols-${1:3} gap-${2:4}\">",
      "  ${3:Content}",
      "</div>",
      ""
    ],
    "description": "Tailwind CSS grid layout"
  },
  "shadcn Dialog": {
    "prefix": "shadcnDialog",
    "body": [
      "<Dialog>",
      "  <DialogTrigger asChild>",
      "    <Button>${1:Open Dialog}</Button>",
      "  </DialogTrigger>",
      "  <DialogContent>",
      "    <DialogHeader>",
      "      <DialogTitle>${2:Dialog Title}</DialogTitle>",
      "      <DialogDescription>",
      "        ${3:Dialog description}",
      "      </DialogDescription>",
      "    </DialogHeader>",
      "    ${4:Dialog content}",
      "  </DialogContent>",
      "</Dialog>",
      ""
    ],
    "description": "shadcn/ui Dialog component"
  },
  "shadcn Input Field": {
    "prefix": "shadcnInput",
    "body": [
      "<div className=\"grid gap-2\">",
      "  <Label htmlFor=\"${1:fieldName}\">${2:Label}</Label>",
      "  <Input",
      "    id=\"${1:fieldName}\"",
      "    type=\"${3:text}\"",
      "    placeholder=\"${4:Enter value}\"",
      "    {...register('${1:fieldName}')}",
      "  />",
      "  {errors.${1:fieldName} && (",
      "    <p className=\"text-sm text-destructive\">{errors.${1:fieldName}.message}</p>",
      "  )}",
      "</div>",
      ""
    ],
    "description": "shadcn/ui Input with Label and error"
  },
  "OpenAI API Call": {
    "prefix": "openaiCall",
    "body": [
      "const completion = await openai.chat.completions.create({",
      "  model: '${1:gpt-4o}',",
      "  messages: [",
      "    {",
      "      role: 'system',",
      "      content: '${2:You are a helpful assistant.}'",
      "    },",
      "    {",
      "      role: 'user',",
      "      content: ${3:userMessage}",
      "    }",
      "  ],",
      "  temperature: ${4:0.7},",
      "});",
      "",
      "const response = completion.choices[0].message.content;",
      ""
    ],
    "description": "OpenAI API completion call"
  },
  "React Query API Hook": {
    "prefix": "useApiQuery",
    "body": [
      "export const use${1:Resource} = (${2:id}: string) => {",
      "  return useQuery({",
      "    queryKey: ['${3:resource}', ${2:id}],",
      "    queryFn: async () => {",
      "      const response = await fetch(`/api/${3:resource}/${${2:id}}`);",
      "      if (!response.ok) {",
      "        throw new Error('Failed to fetch ${3:resource}');",
      "      }",
      "      return response.json();",
      "    },",
      "  });",
      "};",
      ""
    ],
    "description": "React Query hook for API endpoint"
  },
  "Express Route with Session": {
    "prefix": "expressSession",
    "body": [
      "app.${1:get}('${2:/api/endpoint}', async (req, res) => {",
      "  if (!req.session?.userId) {",
      "    return res.status(401).json({ error: 'Not authenticated' });",
      "  }",
      "  ",
      "  const userId = req.session.userId;",
      "  const customerId = req.session.customerId;",
      "  ",
      "  try {",
      "    ${3:// Your logic here}",
      "    ",
      "    res.json({ success: true, data: ${4:result} });",
      "  } catch (error) {",
      "    console.error('Error in ${2:/api/endpoint}:', error);",
      "    res.status(500).json({ error: 'Internal server error' });",
      "  }",
      "});",
      ""
    ],
    "description": "Express route with session authentication"
  },
  "Drizzle Select with Where": {
    "prefix": "drizzleSelect",
    "body": [
      "const ${1:results} = await db",
      "  .select()",
      "  .from(${2:tableName})",
      "  .where(",
      "    and(",
      "      eq(${2:tableName}.customerId, customerId),",
      "      eq(${2:tableName}.${3:column}, ${4:value})",
      "    )",
      "  );",
      ""
    ],
    "description": "Drizzle ORM select with customer isolation"
  },
  "shadcn Card with Form": {
    "prefix": "cardForm",
    "body": [
      "<Card>",
      "  <CardHeader>",
      "    <CardTitle>${1:Form Title}</CardTitle>",
      "    <CardDescription>",
      "      ${2:Form description}",
      "    </CardDescription>",
      "  </CardHeader>",
      "  <CardContent>",
      "    <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">",
      "      ${3:// Form fields}",
      "      <Button type=\"submit\">${4:Submit}</Button>",
      "    </form>",
      "  </CardContent>",
      "</Card>",
      ""
    ],
    "description": "shadcn Card with form structure"
  },
  "React Query Mutation": {
    "prefix": "useMutationApi",
    "body": [
      "const ${1:mutation} = useMutation({",
      "  mutationFn: async (data: ${2:DataType}) => {",
      "    const response = await fetch('${3:/api/endpoint}', {",
      "      method: '${4:POST}',",
      "      headers: { 'Content-Type': 'application/json' },",
      "      body: JSON.stringify(data),",
      "    });",
      "    ",
      "    if (!response.ok) {",
      "      throw new Error('${5:Operation failed}');",
      "    }",
      "    ",
      "    return response.json();",
      "  },",
      "  onSuccess: () => {",
      "    queryClient.invalidateQueries({ queryKey: ['${6:queryKey}'] });",
      "    ${7:// Success handling}",
      "  },",
      "  onError: (error) => {",
      "    console.error('Mutation error:', error);",
      "    ${8:// Error handling}",
      "  },",
      "});",
      ""
    ],
    "description": "React Query mutation for API calls"
  },
  "Zod Form Schema": {
    "prefix": "zodForm",
    "body": [
      "const ${1:formSchema} = z.object({",
      "  ${2:fieldName}: z.string().min(1, '${3:Field is required}'),",
      "  ${4:email}: z.string().email('Invalid email address'),",
      "  $5",
      "});",
      "",
      "type ${6:FormData} = z.infer<typeof ${1:formSchema}>;",
      "",
      "const form = useForm<${6:FormData}>({",
      "  resolver: zodResolver(${1:formSchema}),",
      "  defaultValues: {",
      "    ${2:fieldName}: '',",
      "    ${4:email}: '',",
      "  },",
      "});",
      ""
    ],
    "description": "Zod schema with react-hook-form setup"
  }
}
